#!/bin/bash
# read the iteration times from a spark_stdout file, and compile the metrics

. spark_vars

get_num_matches () {
	grep -E "$regexp" "$1" | wc -l
}

get_times() {
	n=$(get_num_matches $1)
	if [ "$n" -gt 0 ]; then
		grep -E "$regexp" "$1" | cut -d ":" -f1
	else
		echo
	fi
}

# process a file; for each match of regexp, print the iteration metrics
process_file ()
{
	# create an array of times
	read -a <<< $(get_times $file) times

	num_matches=${#times[@]}
	if [ "$num_matches" -eq 0 ]; then
		echo "$(basename $0): Warning: no matches found for $regexp in $file"
		return 1
	fi

	for k in $(seq 0 $((num_matches-2)) ); do
		t1=${times[$k]}
		t2=${times[$((k+1))]}

		pair="-1 $((t1-delay)) -2 $((t2+delay))"

		iter_dir="$outputdir/$iter_dir_prefix$((k+1))"
		if [ ! -d "$iter_dir" ]; then
			mkdir -p "$iter_dir"
		fi

		d_flag="-d $iter_dir"
		s_flag="-s $suffix"
		m_flag="-m '$metrics' "

		echo metperit $pair $d_flag $m_flag $s_flag $iter_dir 1>&2

		metperit \
			$pair \
			$d_flag \
			$s_flag \
			"$ganglia_src_dir"

	done

	return 0
}

optstring="0:m:s:d:g:r:p:"
while getopts $optstring opt
do
	case $opt in
		0)
			delay="$OPTARG"
			;;
		r)
			regexp="$OPTARG"
			;;
		d)
			outputdir="$OPTARG"
			;;
		p)
			iter_dir_prefix="$OPTARG"
			;;
		g)
			ganglia_src_dir="$OPTARG"
			;;
		s)
			suffix="$OPTARG"
			;;
		m)
			metrics="$OPTARG"
			;;
		?)
			echo "invalid option -$opt" 1>&2
			;;
		:)
			echo "-$opt requires argument"
			exit 1
			;;
	esac
done

shift $((OPTIND-1))

if [ -z "$@" ]; then
	echo "$(basename $0): no input files specified"
	echo "$(basename $0): usage: call on spark_stdout" 
	exit 1
fi

if [ -z "$delay" ]; then
	delay=0
fi

if [ -z "$iter_dir_prefix" ]; then
	iter_dir_prefix="it-"
fi

if [ -z "$suffix" ]; then
	suffix="-fil"
fi

if [ -z "$ganglia_src_dir" ]; then
	ganglia_src_dir="$PWD/$GANGLIA_DATA_DIR"
	echo "$(basename $0): Warning: ganglia src dir unspecified; using $ganglia_src_dir" 1>&2
fi

if [ -z "$metrics" ]; then
	metrics="$GANGLIA_METRICS"
fi

if [ -z "$outputdir" ]; then
	outputdir="$PWD"
fi

if [ -z "$regexp" ]; then
	int='[[:digit:]]+'
	float="[[:digit:]\-\.\E\e\+]+"
	sep1=': '
	sep2=','
	regexp="$int$sep1$int$sep2$float"
	echo "$(basename $0): Warning: regexp unspecified; using $regexp" 1>&2
fi

for file in "$@"; do
	if [ ! -r "$file" ]; then
		echo "$(basename $0): Warning: $file is not readable" 1>&2
		continue
	fi
	process_file 
done
